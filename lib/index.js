// Generated by CoffeeScript 2.4.0
var handlebars, is_object_literal,
  indexOf = [].indexOf;

handlebars = require('handlebars');

({is_object_literal} = require('mixme'));

module.exports = function(context, options = {}) {
  var _get, _render, _set, init, proxify, proxy, visiting, visits;
  // Default templated engine
  if (options.render == null) {
    options.render = function(source, proxy) {
      var template;
      template = handlebars.compile(source);
      return template(proxy, options.handlebars);
    };
  }
  if (options.partial == null) {
    options.partial = void 0;
  }
  // Tracking graph traversal
  visits = [];
  visiting = [];
  // Work on properties
  _get = function(keys) {
    var i, j, key, len, value;
    value = context;
    for (i = j = 0, len = keys.length; j < len; i = ++j) {
      key = keys[i];
      value = value[key];
    }
    return value;
  };
  _set = function(keys, value) {
    var i, j, key, len, results, search;
    search = context;
    results = [];
    for (i = j = 0, len = keys.length; j < len; i = ++j) {
      key = keys[i];
      if (i < keys.length - 1) {
        results.push(search = search[key]);
      } else {
        results.push(search[key] = value);
      }
    }
    return results;
  };
  _render = function(keys, value) {
    var keys_as_string;
    keys_as_string = JSON.stringify(keys);
    // Update context with new value if not already visited
    if (indexOf.call(visits, keys_as_string) < 0) {
      if (indexOf.call(visiting, keys_as_string) >= 0) {
        throw Error(`Circular Reference: graph is ${[...visiting, [visiting[0]]].join(' -> ')}`);
      }
      visiting.push(keys_as_string);
      value = options.render(value, proxy);
      visiting.pop();
      _set(keys, value);
      visits.push(keys_as_string);
    }
    return value;
  };
  // Clone the context by recursively converting it into proxies
  proxify = function(obj, keys, partial) {
    var key, proxies, value;
    proxies = {};
    for (key in obj) {
      value = obj[key];
      if (!is_object_literal(value)) {
        continue;
      }
      if ((partial != null) && !partial[key]) {
        continue;
      }
      proxies[key] = proxify(value, [...keys, key], ((partial != null) && is_object_literal(partial[key]) ? partial[key] : void 0));
    }
    return new Proxy(obj, {
      get: function(target, key) {
        if ((partial != null) && !partial[key]) {
          return _get([...keys, key]);
        }
        value = _get([...keys, key]);
        if (is_object_literal(value)) {
          return proxies[key];
        } else if (typeof value === 'string') {
          return _render([...keys, key], value);
        } else {
          return value;
        }
      },
      // Returned object if modified after being proxyfied
      set: function(target, key, value) {
        proxies[key] = value;
        return target[key] = value;
      }
    });
  };
  proxy = proxify(context, [], options.partial);
  // Trigger templating on every properties
  init = function(search, keys, partial) {
    var key, results, value;
    results = [];
    for (key in search) {
      value = search[key];
      if ((partial != null) && !partial[key]) {
        continue;
      }
      // String interpreted as a template
      if (typeof value === 'string') {
        results.push(_render([...keys, key], value));
      } else {
        results.push(init(search[key], [...keys, key], ((partial != null) && is_object_literal(partial[key]) ? partial[key] : void 0)));
      }
    }
    return results;
  };
  if (options.compile) {
    init(context, [], options.partial);
  }
  // Return the result
  return proxy;
};
